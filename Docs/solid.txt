1. اصل تک مسئولیتی (Single Responsibility Principle)
هر کلاسی که توی برنامه‌ی ما وجود داره، باید یک مسئولیت خاص و مشخص داشته. در واقع این کلاس باید فقط و فقط مسئول یک عملکرد توی برنامه باشه.
class User {
  public information() {}
  public sendEmail() {}
  public orders() {}
}
توی این کلاس ما سه تا متد داریم. متد information که اطلاعات کاربر رو برمیگردونه. متد sendMail برای ارسال ایمیل به کاربر و متد orders سفارش‌های کاربر رو برمی‌گردونه.

به نظرتون اگه کلاسی به اسم User داشته باشیم، هدف این کلاس چی هست؟ احتمالاً اطلاعاتی از کاربر رو ذخیره کنه یا نمایش بده. در واقع مسئولیتی در حوزه مربوط به یک کاربر. اگه به کلاس دقت کنیم، می‌بینیم که توی این کلاس، فقط متد information هست که با کلاس User مرتبط هست و بقیه متدها وظایفی متفاوت با این کلاس دارن.

کلاس User نباید مسئول ارسال ایمیل و یا هندل کردن سفارشات کاربر باشه. در این صورت کلاس ما با عملکردهای ذاتی خودش محصور شده نیست. یعنی کلاس User با یک سری عملکردهای غیرمرتبط آمیخته شده.

این مسئله زمانی مشکل‌ساز میشه که می‌خوایم کلاس رو گسترش بدیم. مثلاً ایمیل‌های مختلف و اختصاصی‌تر بفرستیم. که آخر کار نمی‌دونیم این کلاس User هست یا Email !
class User {
  public information() {}
}

class Email {
  public send(user: User) {}
}

class Order {
  public show(user: User) {}
}

2. اصل باز - بسته (Open/Closed Principle)
موجودیت‌های یک نرم‌افزار (کلاس‌ها، ماژول‌ها، توابع و ...) باید برای توسعه داده شدن، باز و برای تغییر دادن، بسته باشن
class Hello {
    public say(lang) {
        if (lang == 'pr') {
            return 'درود';
        } else if (lang == 'en') {
            return 'Hi';
        }
    }
}

let obj = new Hello;
console.log(obj.say('pr'));
این کلاس، با توجه به زبان ورودی، به ما سلام میکنه. همونطور که می‌بینیم درحال حاضر ۲ زبان توسط متد say پشتیبانی میشه. اگه بخوایم زبان‌های دیگه رو اضافه کنیم چطور؟ باید متد say رو ویرایش کنیم:

class Hello {
    public say(lang) {
        if (lang == 'pr') {
            return 'درود';
        } else if (lang == 'en') {
            return 'Hi';
        } else if (lang == 'fr') {
            return 'Bonjour';
        } else if (lang == 'de') {
            return 'Hallo';
        }
    }
}

let obj = new Hello;
console.log(obj.say('de'));
خب یه راه حل بهتر اینه که ما متد say رو کلی تر و عمومی تر بنویسیم. یعنی جوری که بدون توجه به تغییرات و نیازهای جدید، مستقل و دست نخورده باقی بمونه. به اصلاح Abstract کنیم. یعنی عمومی‌تر کردن.

خب برای اینکار، مثال رو به شکل زیر تغییر می‌دیم:
class Persian {
    public sayHello() {
        return 'درود';
    }
}

class French {
    public sayHello() {
        return 'Bonjour';
    }
}

class Hello {
    public say(lang) {
        return lang.sayHello();
    }
}


myHello = new Hello();
myHello.say(new Persian());
3. اصل جایگزینی لیسکوف (Liskov Substitution Principle)
اگر S یک زیر کلاس T باشه، آبجکت‌های نوع T باید بتونن بدون تغییر دادن کد برنامه، با آبجکت‌های نوع S جایگزین بشن.
به بیان ساده‌تر کلاس‌های فرزند نباید رفتار و ویژگی‌های کلاس والد رو تغییر بدن